# RFC: 文件管理（单一节点表 + 文件树）

## 背景

现有问题参见 `docs/zh/references/file-arch-problems.md`，核心矛盾包括：

- 职责边界割裂与一致性风险（问题 1/2/3/11）。
- 去重机制与用户可见性冲突（问题 4）。
- 缺少结构化目录树与统一检索入口（问题 6/10）。
- 业务来源不可区分、引用关系不显式（问题 5/7）。
- 笔记体系与全局文件管理割裂（问题 9）。
- 元数据生成多入口导致策略不一致（问题 13）。

因此需要以“单一节点表 + 文件树 + 引用关系”作为新的文件管理基础，以解决上述结构性问题。

## 范畴说明

- 本 RFC 覆盖节点模型、文件树结构、核心流程与迁移方向。
- 不涉及 UI 交互与具体页面改动。
- 不讨论元信息编辑（如改名、标签）之外的业务流程变更。

补充说明：

- 对话内复用应用内部文件的交互不在本 RFC 范围内，但在实现文件树后应可通过业务流程接入。（问题 8）
- 笔记体系需要迁移到本文件树架构之下，纳入统一节点表与引用关系。（问题 9/10）
- 迁移细节与策略仍待定，后续单独补充。（问题 12）
- `FileMetadata` 等元数据生成应收口到统一工厂入口，避免多入口策略不一致。（问题 13）

## 问题导向设计目标

- 统一主进程入口与一致性保障，消除职责边界割裂。（问题 1/2/3/11）
- 放弃去重，让用户视角文件保持独立。（问题 4）
  - 可保留重复文件检查，由用户决定具体行为。
- 以单一节点表表达文件与目录，并形成可检索的目录树。（问题 6/10）
- 用显式引用关系表达业务使用情况与来源。（问题 5/7）
- 为笔记体系与对话复用提供结构基础。（问题 8/9）
- 为迁移与扩展提供清晰的演进方向。（问题 12/13）

## 设计方案

### 单一节点表 + 文件树（问题 4/6/10）

节点是唯一的文件/目录实体，应当保证与 OS 文件系统的目录结构保持一致。

建议字段：

- `id`: 节点 ID
- `type`: 节点类型（file / dir）
- `name`: 用户可见文件名
- `ext`: 扩展名（文件节点，去掉前导点）
- `parent_id`: 父节点 ID（根节点为 null）
- `created_at`: 创建时间
- `updated_at`: 更新时间
- `meta`: 可扩展元信息（可选）

说明：

- 目录结构以 OS 文件系统为准，且不做内容去重。
- 节点表是目录树的索引层，便于搜索、排序与业务关联。
- 节点类型与文件管理模块解耦，可用于描述应用外部的文件树。
- `path` 不作为持久化字段，运行时由树关系与根节点配置构建（参考 `docs/zh/references/vscode-explorer-tree-overview.md` 的模型分层）。

补充约束：

- 需要有“根节点/挂载点”概念以支持外部文件树，运行时路径由根节点配置 + 目录层级组合生成。

文件树由节点表的 `parent_id` 关系组成，直接对应 OS 文件系统结构：

- 目录节点与文件节点同表管理。
- 目录结构可在 OS 中直接查看与维护。
- 节点是可变实体，重命名/移动/编辑直接作用于文件系统与节点表。
- 应当避免让用户直接操作 OS 中的文件目录，这会导致结构与db不同步。

### 文件引用关系（File Ref）（问题 5/7）

用于从文件节点查询被哪些功能使用，或从功能查询使用了哪些文件。

建议字段：

- `id`: 关系 ID
- `node_id`: 文件/目录节点 ID
- `source_type`: 业务来源（chat / knowledge / note / ...）
- `source_id`: 业务对象 ID
- `role`: 关系语义（attachment / asset / source / ...）
- `created_at`: 创建时间
- `meta`: 可扩展元信息（可选）

约束：

- 业务写入或删除引用时需要同步维护关系记录。
- 是否允许目录节点建立引用关系由具体业务决定，需在对应业务中定义语义与处理规则。
- `source_type` 与 `role` 需有最小枚举集合，避免语义碎片化。

示例：

- `{ id: "ref_001", node_id: "node_a1b2", source_type: "chat_message", source_id: "msg_1001", role: "attachment", created_at: "2025-12-26T12:00:00Z" }`
  - 表示对话消息 `msg_1001` 使用了节点 `node_a1b2` 作为附件文件。
- `{ id: "ref_002", node_id: "node_c3d4", source_type: "knowledge_item", source_id: "kb_42", role: "source", created_at: "2025-12-26T12:05:00Z" }`
  - 表示知识库条目 `kb_42` 使用了节点 `node_c3d4` 作为来源文件。

### 统一入口与一致性要求（问题 1/2/3/11）

- 通过统一入口由 main 管理所有落地写入，renderer 仅维护逻辑索引。
- main 进程负责“物理写入 + 节点登记”的原子性保障。
- 任何失败都必须回滚物理文件或节点记录，避免半成状态。
- renderer 不得绕过 main 直接写入节点表。
- 具体实现机制在后续设计/实现文档中补充。

### 元数据统一入口（问题 13）

- `FileMetadata` 等元数据生成收口到统一工厂入口。
- 保证 `ext`/`type` 生成策略一致，避免多入口规则漂移。

### 业务接入约束（问题 8/9）

- 对话内复用应用内部文件的交互不在本 RFC 范围内，但文件树与引用关系提供可接入基础。
- 笔记体系需要迁移到本文件树架构之下，纳入统一节点表与引用关系。

## 关键流程

### 上传

1. main 接收上传请求并写入目标目录。
2. 生成文件节点（不去重）。
3. renderer 写入节点表或接收 main 返回的节点记录。

补充约束：

- 允许同名文件存在，底层存储文件名为 `id + ext`，不与用户可见名称冲突。

### 删除节点

- 删除节点记录。
- 删除对应的物理文件或目录（递归）。

### 内容编辑

- 直接修改节点对应的真实文件。
- 更新节点 `updated_at` 与元信息。

### 元信息编辑

- 更新节点字段（如 `name`、`meta`）。
- 需要同步更新真实文件名（文件系统 rename）。

## 迁移与兼容（待定）

- 现有 `db.files` 需要迁移为“节点表”结构。
- 历史数据中 `name` 字段将被抛弃，迁移后统一使用旧的 `origin_name` 填充新节点的 `name`。
- `ext` 字段迁移时去除前导点。
- 旧的 `count` 引用计数将被废弃。
- 引用次数由 `file_ref` 聚合得到，替代原有 `count` 语义。

## 取舍记录（Trade-off）

放弃文件池/去重的主要原因与代价：

- 优点：OS 目录结构与用户视角一致，导出/备份更直观。
- 代价：磁盘占用增加，重复内容不再复用。
- 影响：引用计数与 COW 的价值降低，逻辑显著简化。

## 待讨论问题

- 是否需要持久化 `path` 字段（当前设计不保留，以树关系运行时构建）。
- 文件与目录根节点的初始化策略（例如 `filesPath`/`notesPath` 分区）。
